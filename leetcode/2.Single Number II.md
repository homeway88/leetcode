#Day2：Single Number II【难度2】

题目：找出数组中只出现过一次的数字，其它数字都严格出现三次，算法必须是线性时间复杂度，空间复杂度为常数。

>Given an array of integers, every element appears three times except for one. Find that single one.
>
>Note:
>
>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
>
>[https://oj.leetcode.com/problems/single-number-ii/](https://oj.leetcode.com/problems/single-number-ii/ "https://oj.leetcode.com/problems/single-number-ii/")
>
>博文链接：[http://www.coderblog.cn/article/51/](http://www.coderblog.cn/article/51/ "http://www.coderblog.cn/article/51/")



思路：

* 排序法，排完序只要每三个三个地看，如果三个数字不相同，则第一个只出现过一次。如[1,1,1,2,3,3,3],时间复杂度为nlogn。
* 计数法，使用HashMap或者Dict数据结构进行计数，计数后看哪个计数为1即可。每次操作时间为O(1)，总时间复杂度为O(n),但空间复杂度也为O(n)，不满足题目要求。

此题必须从二制的角度来看，在计算机中，int类型用4字节共32位来表示，比如：

 1 ： 0000 0000 0000 0000 0000 0000 0000 0001

-1 :  1111 1111 1111 1111 1111 1111 1111 1111 

每个数字的二进制表示都是唯一的。

我们以数组[A,A,A,B,C,C,C]为例，我们在遍历数组的时候，对每一位上的1进行计数，最终对3求余，如果余数为1，则B在该位上的二进制码为1，否则为0；这是因为，在每一位上，A和C要么是0个1，要么是3个1，都是3的倍数，我们对3求余，则会去除这些数字的影响，最终只留下B在该位上的数字。

例子，数组[-1,-1,-1,1,1,1,2] ,倒数第二行为每一位上对1进行计数，倒数第一行为对计数值对3求余数的结果，可以看到求余结果和数字2的二进制码是完全一致的。

	 -1:  1111 1111 1111 1111 1111 1111 1111 1111  
	 -1:  1111 1111 1111 1111 1111 1111 1111 1111  
	 -1:  1111 1111 1111 1111 1111 1111 1111 1111  
	  1：  0000 0000 0000 0000 0000 0000 0000 0001  
	  1：  0000 0000 0000 0000 0000 0000 0000 0001  
	  1：  0000 0000 0000 0000 0000 0000 0000 0001  
	  2：  0000 0000 0000 0000 0000 0000 0000 0010  

	  1：  3333 3333 3333 3333 3333 3333 3333 3346  
	 %3：  0000 0000 0000 0000 0000 0000 0000 0010  

注意在python中，对数值0xFFFFFFFF作为整数进行显示时，会显示一个很大的正整数，而不会显示负数，故我们需要自行进行负数的转换。负数的补码为=原码取反后加1，原码=补码取反后加1，根据此性质，假如结果最高位为1，则结果为负数，我们进行一次转换：`-((result ^ 0xFFFFFFFF) + 1)`

